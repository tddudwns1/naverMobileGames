"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.runTcr = void 0;

var _react = _interopRequireDefault(require("react"));

var _ink = require("ink");

var _shell = require("./tech/shell");

var _watch = require("./tech/watch");

var _sleep = require("./tech/sleep");

var _git = require("./tech/git");

var _components = require("./components");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var preflightTCRLoop = function preflightTCRLoop(buildAndTestCommand) {
  (0, _shell.exec)(buildAndTestCommand, {
    onPass: function onPass(output) {
      (0, _ink.render)(_react.default.createElement(_components.PassSummary, {
        path: '.',
        outputText: output,
        stats: (0, _git.gitStats)()
      }));
    },
    onFail: function onFail(output) {
      (0, _ink.render)(_react.default.createElement(_components.TestFailingBeforeWeStartError, {
        outputText: output
      }));
      process.exit(1);
    },
    onProgress: function onProgress(output) {
      (0, _ink.render)(_react.default.createElement(_components.RunningSummary, {
        path: '.',
        outputText: output
      }));
    }
  });
};

var TIME_TO_WAIT_BEFORE_RESETTING = 100; // Required if git reset is too quick and editors ignore the file changes

var gitResetRun = false;

var repeatableTCRLoop = function repeatableTCRLoop(buildAndTestCommand, path) {
  if (gitResetRun === true) {
    // ignore the run immediately after a reset, so the user can read the failure message
    gitResetRun = false;
    return;
  }

  (0, _shell.exec)(buildAndTestCommand, {
    onPass: function onPass(output) {
      (0, _git.gitCommit)('working', function () {
        (0, _ink.render)(_react.default.createElement(_components.PassSummary, {
          path: path,
          outputText: output,
          stats: (0, _git.gitStats)()
        }));
      });
    },
    onFail: function onFail(output) {
      (0, _sleep.sleep)(TIME_TO_WAIT_BEFORE_RESETTING).then(function () {
        gitResetRun = true;
        (0, _git.gitReset)();
        (0, _ink.render)(_react.default.createElement(_components.FailSummary, {
          path: path,
          outputText: output,
          stats: (0, _git.gitStats)()
        }));
      });
    },
    onProgress: function onProgress(output) {
      (0, _ink.render)(_react.default.createElement(_components.RunningSummary, {
        path: path,
        outputText: output
      }));
    }
  });
};

var TIME_TO_WAIT_BEFORE_RUNNING = 50; // In case multiple files have been saved

var repeatableTCRLoopWithWait = function repeatableTCRLoopWithWait(path) {
  (0, _sleep.sleep)(TIME_TO_WAIT_BEFORE_RUNNING).then(function () {
    return repeatableTCRLoop(path);
  });
};

var runTcr = function runTcr(buildAndTestCommand) {
  (0, _git.gitStatus)(function (err, changedFiles) {
    if (err) {
      (0, _ink.render)(_react.default.createElement(_components.NoGitRepoError, {
        err: err
      }));
      process.exit(1);
    }

    if (changedFiles.length !== 0) {
      (0, _ink.render)(_react.default.createElement(_components.UncommitedFilesGitError, {
        changedFiles: changedFiles
      }));
      process.exit(1);
    }

    (0, _watch.watch)('.', {
      onReady: function onReady(_) {
        return preflightTCRLoop(buildAndTestCommand);
      },
      onUpdate: function onUpdate(path) {
        return repeatableTCRLoopWithWait(buildAndTestCommand, path);
      }
    });
  });
};

exports.runTcr = runTcr;